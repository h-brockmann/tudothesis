\chapter{Basics}
This chapter provides a collection of basic knowledge as a foundation for this work.

\section{Real Time Operating Systems}
\label{sec:rtos}
A \ac{RTOS} is designed with precise timing and high reliability in mind for running applications \textcite{stankovicRealtimeOperatingSystems2004}. 
Such systems are used in a wide range of applications, from multimedia systems and smart home systems to automotive and medical sectors, such as pacemakers \cite{hambardeSurveyRealTime2014}. 
In all these systems, the correctness and timeliness of the applications are of utmost importance \cite{hambardeSurveyRealTime2014}. 
\subsection{Tasks and Jobs}
\label{sec:tasks_and_jobs}
According to the \citetitle{IEEEStandardRealTime}, a task is defined as the "basic logical unit of concurrent program execution" that contains code. The standard also states that while the code within a task is executed sequentially, the tasks themselves may run in parallel with other tasks.

Tasks can have deadlines based on their importance and the nature of their work. If a task misses its deadline due to insufficient computational time, the system and results may be affected differently. It is common to categorize task deadlines into three types \cite{dengSchedulingRealtimeApplications1997,abeniIntegratingMultimediaApplications1998,shindeComparisonRealTime2017}:
\begin{enumerate}	
\item \textbf{Hard Deadline:} 
Missing a hard deadline is considered a system failure. The task must complete by its deadline; otherwise, the system may enter an unsafe state.
\item \textbf{Firm Deadline:} 
Missing a firm deadline does not cause a system failure, but the task's result is no longer useful and is discarded. The system continues to operate, but the quality of service may degrade.
\item \textbf{Soft Deadline:} 
Missing a soft deadline reduces the task's utility, but the result can still be used. The system can tolerate some deadline misses without significant impact on overall performance.
\end{enumerate}

\subsection{Real-time Scheduling}
\label{sec:scheduling}
Creating the schedule of given tasks to be executed some aspects 

Generating a task set with known \ac{WCET} and \ac{WCRT} requires knowledge about the schedule.
Implementing a scheduler gives the benefit of taking direct insights in the compilation of the generated results. 
To determine the order of operation when being confronted with two or more tasks, the tasks need to get a priority assigned.

There are some scheduling techniques to determine the priority of tasks to be scheduled.
\begin{itemize}
\item \textbf{Clock based Scheduling:}
With clock based scheduling every task gets a share of execution time in which the work of the task may be done.
It is a way to schedule tasks without priorities whilst making sure every task gets time on the computational unit.
While being a simple algorithm it does create a lot of overhead, since the timeslots do not necessarily encompass the whole time needed by the task.
\item \textbf{(Weighted) Round Robin:} 
In basic Round Robin scheduling, each task is assigned a fixed time slice or quantum in a cyclic order, ensuring all tasks get an equal share of CPU time. Weighted Round Robin extends this by assigning different weights to tasks, allowing tasks with higher weights to receive more CPU time compared to tasks with lower weights. This provides a more flexible and efficient scheduling mechanism, especially for systems with tasks of varying importance or computational needs. \cite{helmyOptimizingRoundRobinScheduling2024}
\item \textbf{Rate Monotonic Scheduling:} Rate monotonic scheduling is a fixed priority algorithm where tasks with shorter periods are assigned higher priorities. It is optimal for fixed priority scheduling under certain conditions. \cite{lehoczkyRateMonotonicScheduling1989}
\item \textbf{Earliest Deadline First:} With the earliest deadline first scheduling algorithm, the priority of the tasks is not fixed, but dynamic. As the name implies, the tasks get a priority assigned in a way to ensure the tasks with the nearest upcoming deadline get to run first. \cite{lehoczkyPerformanceRealtimeBus1986}
\end{itemize}

\section{WCET Analysis and Benchmarks}
\label{sec:wcet_analysis_and_benchmarks}
To ensure the reliability and predictability of real-time systems, it is crucial to perform \ac{WCET} analysis. 
WCET analysis involves determining the maximum time a task can take to execute on a given hardware platform. 
This analysis is essential for verifying that all tasks will meet their deadlines under all possible conditions.

\textcite{kelterWCETAnalysisOptimization} mentions several techniques that can be used for \ac{WCET} analysis, including static analysis, measurement-based analysis, and hybrid approaches.
Static analysis involves analyzing the code without executing it, while measurement-based analysis involves running the code on the target hardware and measuring the execution times. 
Hybrid approaches combine both static and measurement-based techniques to provide more accurate \ac{WCET} estimates.

Static analysis is a proper and safe way to get information about the execution times, since it is unhinged from hardware constraints and derived from a meta model created from reviewing the code \cite{kelterWCETAnalysisOptimization}.

To evaluate analysis techniques benchmarks play a significant role.
Providing multiple task sets with known execution scenarios and the tasks behavior the analysis techniques can be tested for its effectiveness. 
Benchmarks commonly used are for example the MÃ¤lardalen \ac{WCET} benchmark and the TACLeBench benchmark suite \cite{falkTACLeBenchBenchmarkCollection2016}.

Accurate \ac{WCET} analysis is critical for the design and verification of real-time systems, ensuring that all tasks can be scheduled and executed within their deadlines, thereby maintaining the system's overall reliability and performance \cite{kelterWCETAnalysisOptimization}.
\textcite{kelterWCETAnalysisOptimization} states further that \ac{WCET} analyses are no longer sufficient for newer and complex systems and need to analyze delays and preemptions between tasks as well.
This results in 
 

\subsection{Critical Instant Theorem}
\label{sec:critial_instant_theorem}
The Critical Instant Theorem, introduced by \textcite{liuSchedulingAlgorithmsMultiprogramming1973}, states that the worst-case response time of a task occurs when it is released simultaneously with all higher-priority tasks. 
This theorem is fundamental in fixed-priority scheduling, as it helps in determining the worst-case scenario for task execution.

According to the theorem, to find the worst-case response time of a task, one must consider the scenario where the task is released at the same time as all higher-priority tasks. 
This situation is known as the critical instant. By analyzing the system under this condition, one can ensure that the calculated response times are indeed the worst-case values.

The theorem is particularly useful in the context of \ac{RMS} and other fixed-priority scheduling algorithms, as it provides a systematic way to evaluate the schedulability of tasks. 
If all tasks meet their deadlines under the critical instant scenario, the system is considered schedulable.

